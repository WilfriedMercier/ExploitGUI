# -*- coding: utf-8 -*-

import yaml
import sys
import cv2
import glob
import os
import os.path           as opath
import cartopy.crs       as crs
import matplotlib        as mpl
import matplotlib.pyplot as plt
import numpy             as np
from   PIL               import Image
from   numpy             import ndarray
from   joblib            import Parallel, delayed
from   typing            import List, Union, Dict, Any, Tuple

def make_projection(image: ndarray, lat: Union[int, float], lon: Union[int, float],
                    output=None) -> None:
    '''
    Generate an azimuthal equidistant projection.
    
    :param str path: path of the input file
    :param str file: input file assumed to be in PlateCarree projection
    :param lat: latitudes where to compute the projection
    :type lat: int, float
    :param lon: longitudes where to compute the projection
    :type lon: int, float
    '''
    
    if output is None or not isinstance(output, str):
        raise TypeError('Output parameter must be specified.')
    
    projection = crs.AzimuthalEquidistant(central_longitude=lon, central_latitude=lat)
    defProj    = crs.PlateCarree()
    
    f          = plt.figure()
    f.set_size_inches(10, 10)
    ax         = plt.axes(projection=projection)
    ax.imshow(image, transform=defProj)
    plt.savefig(output, bbox_inches='tight', facecolor='black', edgecolor='black', dpi=135)
    plt.close(f)
    return
    
def make_projections(path: str, file: str, outpath: str,
                     lat: List[Union[int, float]] = [90], 
                     lon: List[Union[int, float]] = [0]) -> None:
    
    '''
    Generate an azimuthal equidistant projection for a given list of lattitudes and longitudes.
    
    :param str path: path of the input file
    :param str file: input file assumed to be in PlateCarree projection
    :param str outpath: output path
    
    :param lat: (**Optional**) latitudes where to compute the projection
    :type lat: list[int, float]
    :param lon: (**Optional**) longitudes where to compute the projection
    :type lon: list[int, float]
    '''

    def exec(pos):
        la = lat[pos]
        lo = lon[pos]
        print(la, lo, f'{pos/len(lon):.2%}')
        make_projection(image, la, lo, output=opath.join(outpath, f'{fnext}_{pos}.png'))
        return
    
    # Get input image
    fname = opath.join(path, file)
    fnext = file.rsplit(".", maxsplit=1)[0]
    image = mpl.image.imread(fname)
    
    if not isinstance(lat, (list, tuple)):
        raise TypeError(f'latitude has type {type(lat)} but it must have type list.')
        
    if not isinstance(lon, (list, tuple)):
        raise TypeError(f'longitude has type {type(lon)} but it must have type list.')

    Parallel(n_jobs=7)(delayed(exec)(pos) for pos in range(len(lon)))
    return

def loadConf(path: str, file: str) -> Dict[str, Any]:
    '''
    Load one of the configuration files.
    
    :param str path: path
    :param str file: file name
    
    :returns: dictionary for a given planet
    :rtype: dict
    '''
    
    fname   = opath.join(path, file)
    if not opath.exists(fname):
        raise IOError(f'file {file} (expanded as {fname}) not found.')

    with open(fname, 'r') as f:
        out = yaml.load(f, Loader=yaml.Loader)
        
    return out

def makeMovie(fpath:str, fname: str, moviePath: str, movieName: str, fps: int, dim: Tuple[int, int]) -> None:
    '''
    Make a movie out of a set of images.
    
    :param str fpath: path of the input files
    :param str fname: input file base name
    :param str moviePath: path of the output movie file
    :param str movieName: name of the ouput file
    :param int fps: frames per second
    :param tuple[int] dim: dimensions of the output images
    '''
    
    fourcc   = cv2.VideoWriter_fourcc(*"MJPG")
    out      = cv2.VideoWriter(opath.join(moviePath, movieName), fourcc, fps, dim, True)
    
    for i in range(int(fps*dur)):
        file = opath.join(fpath, f'{fname}_{i}.png')
        img  = cv2.imread(file).astype('uint8')
        out.write(img)
        
    out.release()
    return

###########################################
#        Open input and conf files        #
###########################################

pathIn     = opath.join('..', 'data', 'textures', 'default')

if len(sys.argv) != 2:
    raise IOError('An input file name must be provided.')
else:
    conf   = loadConf(opath.join('..', 'data', 'projections', 'conf'), sys.argv[1])
    file   = conf['file']
    fname  = file.rsplit(".", maxsplit=1)[0]

    lat    = 90-conf['tilt']   # degrees
    fps    = conf['fps']       # frame per second
    dur    = conf['duration']  # seconds 

##########################################
#            Make projections            #
##########################################

# Latitudes and longitudes
lon        = list(np.linspace(-180, 180, int(fps*dur)))
lat        = [lat]*len(lon)

# Make projection files
tmp_dir    = opath.join('..', 'data', 'projections', 'tmp')
if not opath.isdir(tmp_dir):
    os.mkdir(tmp_dir)

#'''
for tmp_file in glob.glob(opath.join(tmp_dir, f'{fname}_*.png')):    
    os.remove(tmp_file)
               
make_projections(pathIn, file, tmp_dir, lat, lon)
#'''

##############################
#         Make movie         #
##############################

# Get dimensions of image
dim        = Image.open(opath.join(tmp_dir, f'{fname}_0.png')).size[::-1]

# Generate the movie
mPath      = opath.join('..', 'data', 'projections')
movie      = f'{fname}.avi'
if opath.isfile(opath.join(mPath, movie)):
    os.remove(opath.join(mPath, movie))
    
makeMovie(tmp_dir, fname, mPath, movie, fps, dim)

    
    
    
    
